# Builder建造模式

## 使用示例

通过Lombok的@Builder注解使用

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ApiModel(description = "员工登录返回的数据格式")
public class EmployeeLoginVO implements Serializable {
    @ApiModelProperty("主键值")
    private Long id;

    @ApiModelProperty("用户名")
    private String userName;

    @ApiModelProperty("姓名")
    private String name;

    @ApiModelProperty("jwt令牌")
    private String token;
}
```



```java
    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    public BaseResponse<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录: {}", employeeLoginDTO);
        Employee employee = employeeService.login(employeeLoginDTO);

        // 登录成果生成Jwt令牌
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return BaseResponse.success(employeeLoginVO);
    }
```



## 相比用BeanUtils的copyProperties

```java
EmployeeLoginVO vo = new EmployeeLoginVO();
// 1. 先拷贝能拷贝的 (id, name, username)
BeanUtils.copyProperties(employee, vo); 
// 2. 再手动补上不能拷贝的
vo.setToken(token); 
// 3. 注意：如果 username 在实体里叫 username，在VO里叫 userName，BeanUtils 也拷不过去
```



| **特性**     | **Builder 模式**                                         | **BeanUtils.copyProperties (反射复制)**                     |
| ------------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| **适用场景** | 字段较少、字段名不完全一致、需要额外计算字段（如 Token） | 字段非常多（如20个以上）、且字段名完全一致                  |
| **性能**     | **极快** (普通的方法调用)                                | **较慢** (使用反射机制，有开销)                             |
| **安全性**   | **编译期检查** (写错字段名直接报红)                      | **运行时检查** (写错名字不报错，只是跑起来没数据，难以排查) |
| **灵活性**   | 高 (可以随意映射不同名字的字段)                          | 低 (必须属性名完全一样)                                     |

> `BeanUtils` 的开销确实比直接写 `get/set` 要大，因为它底层使用了**反射（Reflection）**。但是，**在大多数非高并发、非循环处理的业务场景下（比如你的登录接口），这个性能损耗是可以忽略不计的。**



## 属性拷贝的性能梯队

| **排名** | **方式**                                        | **原理**           | **评价**                                                     |
| -------- | ----------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| **NO.1** | **直接 Get/Set** (或 Builder)                   | 硬编码             | **最快**（基准），JVM 会深度优化。                           |
| **NO.2** | **MapStruct** (强烈推荐)                        | **编译期生成代码** | **几乎等于 Get/Set**。它在编译时自动生成了 Get/Set 代码，**运行时没有反射**。 |
| **NO.3** | Cglib BeanCopier                                | 字节码生成         | 很快，接近原生，但API稍微麻烦点。                            |
| **NO.4** | **Spring BeanUtils** (`org.springframework...`) | 优化的反射         | **中规中矩**。Spring 内部做了缓存优化，日常业务逻辑完全够用。 |
| **NO.5** | **Apache BeanUtils** (`org.apache.commons...`)  | 笨重的反射         | **极慢，严禁使用！** 它由于包含大量的类型转换和校验，性能非常差（比 Spring 慢 10 倍以上）。 |

