# Builder建造模式

## 使用示例

通过Lombok的@Builder注解使用

<font color='red'>注意使用了@Builder会导致，类默认的无参构造方式失效，需要补上 @NoArgsConstructor 和 @AllArgsConstructor。</font>

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Scheme(description = "员工登录返回的数据格式")
public class EmployeeLoginVO implements Serializable {
    @Scheme(description = "主键值")
    private Long id;

    @Scheme(description = "用户名")
    private String userName;

    @Scheme(description = "姓名")
    private String name;

    @Scheme(description = "jwt令牌")
    private String token;
}
```

```java
    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    public BaseResponse<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录: {}", employeeLoginDTO);
        Employee employee = employeeService.login(employeeLoginDTO);

        // 登录成果生成Jwt令牌
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return BaseResponse.success(employeeLoginVO);
    }
```



## 相比用BeanUtils的copyProperties

```java
EmployeeLoginVO vo = new EmployeeLoginVO();
// 1. 先拷贝能拷贝的 (id, name, username)
BeanUtils.copyProperties(employee, vo); 
// 2. 再手动补上不能拷贝的
vo.setToken(token); 
// 3. 注意：如果 username 在实体里叫 username，在VO里叫 userName，BeanUtils 也拷不过去
```



| **特性**     | **Builder 模式**                                         | **BeanUtils.copyProperties (反射复制)**                     |
| ------------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| **适用场景** | 字段较少、字段名不完全一致、需要额外计算字段（如 Token） | 字段非常多（如20个以上）、且字段名完全一致                  |
| **性能**     | **极快** (普通的方法调用)                                | **较慢** (使用反射机制，有开销)                             |
| **安全性**   | **编译期检查** (写错字段名直接报红)                      | **运行时检查** (写错名字不报错，只是跑起来没数据，难以排查) |
| **灵活性**   | 高 (可以随意映射不同名字的字段)                          | 低 (必须属性名完全一样)                                     |

> `BeanUtils` 的开销确实比直接写 `get/set` 要大，因为它底层使用了**反射（Reflection）**。但是，**在大多数非高并发、非循环处理的业务场景下（比如你的登录接口），这个性能损耗是可以忽略不计的。**



## 属性拷贝的性能梯队

| **排名** | **方式**                                        | **原理**           | **评价**                                                     |
| -------- | ----------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| **NO.1** | **直接 Get/Set** (或 Builder)                   | 硬编码             | **最快**（基准），JVM 会深度优化。                           |
| **NO.2** | **MapStruct** (强烈推荐)                        | **编译期生成代码** | **几乎等于 Get/Set**。它在编译时自动生成了 Get/Set 代码，**运行时没有反射**。 |
| **NO.3** | Cglib BeanCopier                                | 字节码生成         | 很快，接近原生，但API稍微麻烦点。                            |
| **NO.4** | **Spring BeanUtils** (`org.springframework...`) | 优化的反射         | **中规中矩**。Spring 内部做了缓存优化，日常业务逻辑完全够用。 |
| **NO.5** | **Apache BeanUtils** (`org.apache.commons...`)  | 笨重的反射         | **极慢，严禁使用！** 它由于包含大量的类型转换和校验，性能非常差（比 Spring 慢 10 倍以上）。 |



# Mybatis-Plus的分页配置

## 配置拦截器

```java
package com.hongs.skyserver.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.hongs.skyserver.mapper")
public class MybatisPlusConfig {

    /**
     * 添加分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```



在使用Springboot3的 `mybatis-plus-spring-boot3-starter` 需要引入 `mybatis-plus-jsqlparser`

```
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    <version>3.5.1</version>
</dependency>

<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser</artifactId>
    <version>3.5.1</version>
</dependency>
```

否则 `PaginationInnerInterceptor` 查找不到



## Service 层实现逻辑

```java
    /**
     * 员工分页查询
     * @param pageQueryDTO
     * @return
     */
    @Override
    public PageResult<EmployeePageQueryVO> page(EmployeePageQueryDTO pageQueryDTO) {
        IPage<Employee> iPage = new Page(pageQueryDTO.getPage(), pageQueryDTO.getPageSize());
        LambdaQueryWrapper<Employee> wrapper = new LambdaQueryWrapper<>();
        wrapper.orderByDesc(Employee::getUpdateTime)
                .orderByDesc(Employee::getCreateTime);
        wrapper.like(StringUtils.hasText(pageQueryDTO.getName()), Employee::getName, pageQueryDTO.getName());
        this.page(iPage, wrapper);

        List<EmployeePageQueryVO> voList = iPage.getRecords().stream().map(employee -> {
            EmployeePageQueryVO vo = new EmployeePageQueryVO();
            BeanUtils.copyProperties(employee, vo);
            return vo;
        }).toList();

        return new PageResult<EmployeePageQueryVO>(iPage.getTotal(), voList);
    }
```



# 常用判空方法

分为 **字符串**、**集合/数组**、**通用对象** 三大类来列举



## 一、 字符串判空

字符串的“空”有三种情况：

1. `null` (真空)
2. `""` (空字符串，长度为0)
3. `"   "` (只有空格，长度大于0，但在业务上通常视为无意义)



**字符串判空图解：**

| **输入值**   | **str.isEmpty() (原生)** | **StringUtils.isEmpty (Spring)** | **StringUtils.hasText (Spring) ✅** |
| ------------ | ------------------------ | -------------------------------- | ---------------------------------- |
| `null`       | ❌ 报空指针               | `true`                           | `false`                            |
| `""`         | `true`                   | `true`                           | `false`                            |
| `" "` (空格) | `false`                  | `false` (坑!)                    | **`false`** (智能)                 |
| `"abc"`      | `false`                  | `false`                          | `true`                             |


1. `StringUtils.hasText(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：**最严格**。必须有实际字符才算 true。
- **判断逻辑**：`!= null` **且** `length > 0` **且** `包含非空格字符`。
- **适用场景**：用户名、搜索关键词等不允许只填空格的场景。

2. `StringUtils.isEmpty(str)` / `hasLength(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：只判断有没有长度。
- **坑点**：`"   "` (三个空格) 会被认为是 **有值** (true)。
- **适用场景**：你认为“空格”也是一种有效数据的场景（极少见）。

3. `str.isBlank()`

- **来源**：JDK 11 String 类自带方法

- **作用**：等同于 Spring 的 `!hasText()`。

- **写法**：
	```Java
	if (str != null && !str.isBlank()) { ... }
	```

- **缺点**：因为是实例方法，如果 `str` 本身是 `null`，直接调用 `str.isBlank()` 会报 **空指针异常 (NPE)**。所以必须先判断 `!= null`。



## 二、 集合与 Map 判空 (List, Set, Map)

判断集合是否为 null 或者 size 为 0。

1. `CollectionUtils.isEmpty(list)` 【Spring 推荐】

- **来源**：`org.springframework.util.CollectionUtils`

- **代码**：

	```Java
	List<Employee> list = null;
	if (CollectionUtils.isEmpty(list)) {
	    // list 是 null 或者 size=0 都会进这里
	    return; 
	}
	```

- **优点**：**空指针安全**。如果用原生写法 `list.size() == 0`，当 list 为 null 时会报错。

2. `MapUtils.isEmpty(map)`

- **来源**：`org.apache.commons.collections` (或者 Spring 的 `CollectionUtils` 也可以判断 Map)
- **代码**：`CollectionUtils.isEmpty(map)` (Spring 通吃)



## 三、 对象判空 (Object)

1. `obj == null` (原生，最常用)

- 简单粗暴，如果是普通对象，直接用 `!= null` 即可。

2. `Objects.isNull(obj)` / `Objects.nonNull(obj)` 【Java 7+ 原生】

- **来源**：`java.util.Objects`

- **代码**：

	```Java
	if (Objects.nonNull(employee)) {
	    // ...
	}
	```

- **优点**：适合配合 Java 8 的 `Stream` 流使用，例如 `.filter(Objects::nonNull)`，写在普通 `if` 里只是为了读起来像英语，功能和 `!= null` 一模一样。

3. `ObjectUtils.isEmpty(obj)` 【Spring 全能王】

- **来源**：`org.springframework.util.ObjectUtils`

- **特点**：**万能**。它可以判断 String、List、Map、数组、Optional 甚至是普通对象。

- **代码**：

	```java
	ObjectUtils.isEmpty(new int[]{}); // true
	ObjectUtils.isEmpty("  "); // false (注意！它不检查空格，只检查长度)
	ObjectUtils.isEmpty(null); // true
	```



## 四、 数组判空 (Array)

1. `arr != null && arr.length > 0` (原生)

最基础的写法。

2. `ObjectUtils.isEmpty(arr)` (Spring)

Spring 的 `ObjectUtils` 底层会自动识别这是一个数组，并判断长度。


## 总结：Spring Boot 项目最佳实践

| **数据类型**   | **推荐方法**                    | **理由**                             |
| -------------- | ------------------------------- | ------------------------------------ |
| **String**     | `StringUtils.hasText(str)`      | 唯一能过滤掉“纯空格”的方法，最安全。 |
| **List/Set**   | `CollectionUtils.isEmpty(list)` | 防止 List 为 null 时报空指针。       |
| **Map**        | `CollectionUtils.isEmpty(map)`  | 同上。                               |
| **普通对象**   | `obj != null`                   | 简单直接。                           |
| **Stream流中** | `Objects::nonNull`              | 代码优雅，可读性高。                 |



# Spring Boot 时间格式化

## 方法一：局部注解处理（最灵活，精确控制）

**适用场景：** 特殊字段需要特殊格式（例如绝大多数接口用 `yyyy-MM-dd`，但唯独这个字段要精确到毫秒）。

**核心点：**

1. **`@JsonFormat` (Jackson)**：负责 **JSON 数据** 的序列化和反序列化（出参返回给前端、前端发 JSON Body 进来）。
2. **`@DateTimeFormat` (Spring)**：负责 **URL 参数/表单数据** 的格式化（前端 GET 请求 `?time=...` 传参）。

**代码示例：**

```Java
import com.fasterxml.jackson.annotation.JsonFormat;
import org.springframework.format.annotation.DateTimeFormat;
import java.time.LocalDateTime;

public class EmployeeDTO {

    /**
     * 两个注解同时加，确保万无一失：
     * 1. @DateTimeFormat 让你能接收前端传来的 ?updateTime=2023-12-01 12:00:00
     * 2. @JsonFormat 让接口返回给前端时变成 "2023-12-01 12:00:00" (而不是数组)
     */
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private LocalDateTime updateTime;
}
```


## 方法二：全局配置文件设置（最推荐，零代码）

**适用场景：** 项目中 99% 的时间格式都是统一的（如都是 `yyyy-MM-dd HH:mm:ss`）。这是 Spring Boot 的标准做法。

**核心点：** 通过 `application.yml` 配置 Jackson，一键搞定所有 **JSON** 格式。

**配置示例 (application.yml)：**

```YAML
spring:
  jackson:
    # 设置日期格式 (针对 Date 和 LocalDateTime)
    date-format: yyyy-MM-dd HH:mm:ss
    # 设置时区 (非常重要，否则可能少8小时)
    time-zone: GMT+8
    # 某些版本可能需要显式开启写入时间戳为 false
    serialization:
      write-dates-as-timestamps: false
```

*注意：此方法主要解决 JSON 交互。如果 GET 请求参数解析报错，仍然可能需要配合 `@DateTimeFormat` 或下面的方法三。*



<font color = 'red'>如果继承了WebMvcConfigurationSupport ，或者自定义转换器即实现了WebMvcConfigurer接口，那么yml配置将会失效。</font>

**`WebMvcConfigurationSupport` 是 Spring MVC 的“高级接管模式”。**

当你继承了这个类时，Spring Boot 认为：“**好吧，这个开发者想完全自己控制 MVC 配置，那我就把我自动配置的那套东西（包括读取 `application.yml` 里的 Jackson 配置）全部关掉。**”

**后果就是：**

1. Spring Boot 默认的 `JacksonAutoConfiguration` 失效了。
2. 你的 `application.yml` 里的 `spring.jackson.date-format` 配置被完全忽略了。
3. 系统回退到了最原始的 Jackson 状态（日期默认转为时间戳数组）。



## 方法三：全局代码扩展（最强力，兜底方案）

**适用场景：** 配置文件无法满足需求，或者需要对序列化器做非常复杂的自定义配置（比如你提供的图片中的情况）。

**核心点：** 实现 `WebMvcConfigurer` 接口，重写 `extendMessageConverters`，手动将自定义的 Jackson 转换器加入到 Spring 容器中，并**设为最高优先级**。

```Java
public class JacksonObjectMapper extends ObjectMapper {

    // 定义日期时间的格式常量
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();

        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        // 创建一个模块，用于注册自定义的序列化器和反序列化器
        // ------------------ 反序列化配置 (Input: JSON字符串 -> Java对象) ------------------
        // 当前端传来 "2025-12-01 12:00:00" 时，自动解析为 LocalDateTime 对象
        // ------------------ 序列化配置 (Output: Java对象 -> JSON字符串) ------------------
        // 当后端返回 LocalDateTime 对象时，自动转为 "yyyy-MM-dd HH:mm:ss" 格式的字符串
        SimpleModule module = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        // 将在这个模块中配置的所有规则，注册到 ObjectMapper 中
        this.registerModule(module);
    }
}
```



```java
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 扩展 Spring MVC 框架的消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {

        log.info("扩展消息转换器...");

        // 1. 创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();

        // 2. 需要为消息转换器设置一个对象转换器，对象转换器可以将 Java 对象序列化为 JSON 数据
        converter.setObjectMapper(new JacksonObjectMapper());

        // 3. 将自己的消息转换器加入到容器中
        converters.add(1, converter);
    }
}
```

！<font color='red'>knife4j 4.0.0以上版本不要用最高优先级 0，否则接口文档会异常</font>

> converters.add(1, converter);
>
> 优先级可以选择区间 [1, converters.size() - 1]



## 总结对比

| **方法**                                         | **作用范围**  | **优点**                       | **缺点**                         | **你的选择**               |
| ------------------------------------------------ | ------------- | ------------------------------ | -------------------------------- | -------------------------- |
| **方法一：注解** (@JsonFormat / @DateTimeFormat) | 单个字段      | 灵活，哪里需要加哪里           | 每个字段都要写，容易漏，代码冗余 | **个别特殊字段用它**       |
| **方法二：配置文件** (application.yml)           | 全局 (仅JSON) | 简单，无侵入，不用写 Java 代码 | 对 GET 请求参数支持较弱          | **首选方案**               |
| **方法三：配置类** (WebMvcConfigurer)            | 全局 (JSON)   | 极其强大，可完全掌控序列化逻辑 | 代码量大，逻辑相对复杂           | **当配置文件搞不定时用它** |



# 更新方法修改更通用

## 修改前

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Operation(summary = "启用禁用员工账号")
    @PostMapping("/status/{status}")
    public Result updateStatus(@PathVariable Integer status, Long id) {
        log.info("启用禁用员工账号: {}, {}", status, id);
        employeeService.updateStatus(status, id);
        return Result.success();
    }
```

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     */
    @Override
    public void updateStatus(Integer status, Long id) {
        LambdaUpdateWrapper<Employee> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(Employee::getId, id).set(Employee::getStatus, status);
        this.update(wrapper);
    }
```



## 修改后

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Operation(summary = "启用禁用员工账号")
    @PostMapping("/status/{status}")
    public Result updateStatus(@PathVariable Integer status, Long id) {
        log.info("启用禁用员工账号: {}, {}", status, id);
        employeeService.update(Employee.builder().id(id).status(status).build());
        return Result.success();
    }
```

```java
    /**
     * 通用员工更新
     * @param employee
     */
    @Override
    public void update(Employee employee) {
        LambdaUpdateWrapper<Employee> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(Employee::getId, employee.getId())
                .set(employee.getName() != null, Employee::getName, employee.getName())
                .set(employee.getUsername() != null, Employee::getUsername, employee.getUsername())
                .set(employee.getPassword() != null, Employee::getPassword, employee.getPassword())
                .set(employee.getPhone() != null, Employee::getPhone, employee.getPhone())
                .set(employee.getSex() != null, Employee::getSex, employee.getSex())
                .set(employee.getIdNumber() != null, Employee::getIdNumber, employee.getIdNumber())
                .set(employee.getUpdateTime() != null, Employee::getUpdateTime, employee.getUpdateTime())
                .set(employee.getUpdateUser() != null, Employee::getUpdateUser, employee.getUpdateUser())
                .set(employee.getStatus() != null, Employee::getStatus, employee.getStatus());
        this.update(wrapper);
    }
```

