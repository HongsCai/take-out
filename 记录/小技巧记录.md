

# Builder建造模式

## 使用示例

通过Lombok的@Builder注解使用

<font color='red'>注意使用了@Builder会导致，类默认的无参构造方式失效，需要补上 @NoArgsConstructor 和 @AllArgsConstructor。</font>

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Schema(description = "员工登录返回的数据格式")
public class EmployeeLoginVO implements Serializable {
    @Schema(description = "主键值")
    private Long id;

    @Schema(description = "用户名")
    private String userName;

    @Schema(description = "姓名")
    private String name;

    @Schema(description = "jwt令牌")
    private String token;
}
```

```java
    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    public BaseResponse<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录: {}", employeeLoginDTO);
        Employee employee = employeeService.login(employeeLoginDTO);

        // 登录成果生成Jwt令牌
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return BaseResponse.success(employeeLoginVO);
    }
```



## 相比用BeanUtils的copyProperties

```java
EmployeeLoginVO vo = new EmployeeLoginVO();
// 1. 先拷贝能拷贝的 (id, name, username)
BeanUtils.copyProperties(employee, vo); 
// 2. 再手动补上不能拷贝的
vo.setToken(token); 
// 3. 注意：如果 username 在实体里叫 username，在VO里叫 userName，BeanUtils 也拷不过去
```



| **特性**     | **Builder 模式**                                         | **BeanUtils.copyProperties (反射复制)**                     |
| ------------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| **适用场景** | 字段较少、字段名不完全一致、需要额外计算字段（如 Token） | 字段非常多（如20个以上）、且字段名完全一致                  |
| **性能**     | **极快** (普通的方法调用)                                | **较慢** (使用反射机制，有开销)                             |
| **安全性**   | **编译期检查** (写错字段名直接报红)                      | **运行时检查** (写错名字不报错，只是跑起来没数据，难以排查) |
| **灵活性**   | 高 (可以随意映射不同名字的字段)                          | 低 (必须属性名完全一样)                                     |

> `BeanUtils` 的开销确实比直接写 `get/set` 要大，因为它底层使用了**反射（Reflection）**。但是，**在大多数非高并发、非循环处理的业务场景下（比如你的登录接口），这个性能损耗是可以忽略不计的。**



## 属性拷贝的性能梯队

| **排名** | **方式**                                        | **原理**           | **评价**                                                     |
| -------- | ----------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| **NO.1** | **直接 Get/Set** (或 Builder)                   | 硬编码             | **最快**（基准），JVM 会深度优化。                           |
| **NO.2** | **MapStruct** (强烈推荐)                        | **编译期生成代码** | **几乎等于 Get/Set**。它在编译时自动生成了 Get/Set 代码，**运行时没有反射**。 |
| **NO.3** | Cglib BeanCopier                                | 字节码生成         | 很快，接近原生，但API稍微麻烦点。                            |
| **NO.4** | **Spring BeanUtils** (`org.springframework...`) | 优化的反射         | **中规中矩**。Spring 内部做了缓存优化，日常业务逻辑完全够用。 |
| **NO.5** | **Apache BeanUtils** (`org.apache.commons...`)  | 笨重的反射         | **极慢，严禁使用！** 它由于包含大量的类型转换和校验，性能非常差（比 Spring 慢 10 倍以上）。 |



# Mybatis-Plus的分页配置

## 配置拦截器

```java
package com.hongs.skyserver.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.hongs.skyserver.mapper")
public class MybatisPlusConfig {

    /**
     * 添加分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```



在使用Springboot3的 `mybatis-plus-spring-boot3-starter` 需要引入 `mybatis-plus-jsqlparser`

```
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    <version>3.5.1</version>
</dependency>

<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser</artifactId>
    <version>3.5.1</version>
</dependency>
```

否则 `PaginationInnerInterceptor` 查找不到



## Service 层实现逻辑

```java
    /**
     * 员工分页查询
     * @param pageQueryDTO
     * @return
     */
    @Override
    public PageResult<EmployeePageQueryVO> page(EmployeePageQueryDTO pageQueryDTO) {
        IPage<Employee> iPage = new Page(pageQueryDTO.getPage(), pageQueryDTO.getPageSize());
        LambdaQueryWrapper<Employee> wrapper = new LambdaQueryWrapper<>();
        wrapper.orderByDesc(Employee::getUpdateTime)
                .orderByDesc(Employee::getCreateTime);
        wrapper.like(StringUtils.hasText(pageQueryDTO.getName()), Employee::getName, pageQueryDTO.getName());
        this.page(iPage, wrapper);

        List<EmployeePageQueryVO> voList = iPage.getRecords().stream().map(employee -> {
            EmployeePageQueryVO vo = new EmployeePageQueryVO();
            BeanUtils.copyProperties(employee, vo);
            return vo;
        }).toList();

        return new PageResult<EmployeePageQueryVO>(iPage.getTotal(), voList);
    }
```



# 常用判空方法

分为 **字符串**、**集合/数组**、**通用对象** 三大类来列举



## 一、 字符串判空

字符串的“空”有三种情况：

1. `null` (真空)
2. `""` (空字符串，长度为0)
3. `"   "` (只有空格，长度大于0，但在业务上通常视为无意义)



**字符串判空图解：**

| **输入值**   | **str.isEmpty() (原生)** | **StringUtils.isEmpty (Spring)** | **StringUtils.hasText (Spring) ✅** |
| ------------ | ------------------------ | -------------------------------- | ---------------------------------- |
| `null`       | ❌ 报空指针               | `true`                           | `false`                            |
| `""`         | `true`                   | `true`                           | `false`                            |
| `" "` (空格) | `false`                  | `false` (坑!)                    | **`false`** (智能)                 |
| `"abc"`      | `false`                  | `false`                          | `true`                             |


1. `StringUtils.hasText(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：**最严格**。必须有实际字符才算 true。
- **判断逻辑**：`!= null` **且** `length > 0` **且** `包含非空格字符`。
- **适用场景**：用户名、搜索关键词等不允许只填空格的场景。

2. `StringUtils.isEmpty(str)` / `hasLength(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：只判断有没有长度。
- **坑点**：`"   "` (三个空格) 会被认为是 **有值** (true)。
- **适用场景**：你认为“空格”也是一种有效数据的场景（极少见）。

3. `str.isBlank()`

- **来源**：JDK 11 String 类自带方法

- **作用**：等同于 Spring 的 `!hasText()`。

- **写法**：
	```Java
	if (str != null && !str.isBlank()) { ... }
	```

- **缺点**：因为是实例方法，如果 `str` 本身是 `null`，直接调用 `str.isBlank()` 会报 **空指针异常 (NPE)**。所以必须先判断 `!= null`。



## 二、 集合与 Map 判空 (List, Set, Map)

判断集合是否为 null 或者 size 为 0。

1. `CollectionUtils.isEmpty(list)` 【Spring 推荐】

- **来源**：`org.springframework.util.CollectionUtils`

- **代码**：

	```Java
	List<Employee> list = null;
	if (CollectionUtils.isEmpty(list)) {
	    // list 是 null 或者 size=0 都会进这里
	    return; 
	}
	```

- **优点**：**空指针安全**。如果用原生写法 `list.size() == 0`，当 list 为 null 时会报错。

2. `MapUtils.isEmpty(map)`

- **来源**：`org.apache.commons.collections` (或者 Spring 的 `CollectionUtils` 也可以判断 Map)
- **代码**：`CollectionUtils.isEmpty(map)` (Spring 通吃)



## 三、 对象判空 (Object)

1. `obj == null` (原生，最常用)

- 简单粗暴，如果是普通对象，直接用 `!= null` 即可。

2. `Objects.isNull(obj)` / `Objects.nonNull(obj)` 【Java 7+ 原生】

- **来源**：`java.util.Objects`

- **代码**：

	```Java
	if (Objects.nonNull(employee)) {
	    // ...
	}
	```

- **优点**：适合配合 Java 8 的 `Stream` 流使用，例如 `.filter(Objects::nonNull)`，写在普通 `if` 里只是为了读起来像英语，功能和 `!= null` 一模一样。

3. `ObjectUtils.isEmpty(obj)` 【Spring 全能王】

- **来源**：`org.springframework.util.ObjectUtils`

- **特点**：**万能**。它可以判断 String、List、Map、数组、Optional 甚至是普通对象。

- **代码**：

	```java
	ObjectUtils.isEmpty(new int[]{}); // true
	ObjectUtils.isEmpty("  "); // false (注意！它不检查空格，只检查长度)
	ObjectUtils.isEmpty(null); // true
	```



## 四、 数组判空 (Array)

1. `arr != null && arr.length > 0` (原生)

最基础的写法。

2. `ObjectUtils.isEmpty(arr)` (Spring)

Spring 的 `ObjectUtils` 底层会自动识别这是一个数组，并判断长度。


## 总结：Spring Boot 项目最佳实践

| **数据类型**   | **推荐方法**                    | **理由**                             |
| -------------- | ------------------------------- | ------------------------------------ |
| **String**     | `StringUtils.hasText(str)`      | 唯一能过滤掉“纯空格”的方法，最安全。 |
| **List/Set**   | `CollectionUtils.isEmpty(list)` | 防止 List 为 null 时报空指针。       |
| **Map**        | `CollectionUtils.isEmpty(map)`  | 同上。                               |
| **普通对象**   | `obj != null`                   | 简单直接。                           |
| **Stream流中** | `Objects::nonNull`              | 代码优雅，可读性高。                 |



# Spring Boot 时间格式化

## 方法一：局部注解处理（最灵活，精确控制）

**适用场景：** 特殊字段需要特殊格式（例如绝大多数接口用 `yyyy-MM-dd`，但唯独这个字段要精确到毫秒）。

**核心点：**

1. **`@JsonFormat` (Jackson)**：负责 **JSON 数据** 的序列化和反序列化（出参返回给前端、前端发 JSON Body 进来）。
2. **`@DateTimeFormat` (Spring)**：负责 **URL 参数/表单数据** 的格式化（前端 GET 请求 `?time=...` 传参）。

**代码示例：**

```Java
import com.fasterxml.jackson.annotation.JsonFormat;
import org.springframework.format.annotation.DateTimeFormat;
import java.time.LocalDateTime;

public class EmployeeDTO {

    /**
     * 两个注解同时加，确保万无一失：
     * 1. @DateTimeFormat 让你能接收前端传来的 ?updateTime=2023-12-01 12:00:00
     * 2. @JsonFormat 让接口返回给前端时变成 "2023-12-01 12:00:00" (而不是数组)
     */
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private LocalDateTime updateTime;
}
```


## 方法二：全局配置文件设置（最推荐，零代码）

**适用场景：** 项目中 99% 的时间格式都是统一的（如都是 `yyyy-MM-dd HH:mm:ss`）。这是 Spring Boot 的标准做法。

**核心点：** 通过 `application.yml` 配置 Jackson，一键搞定所有 **JSON** 格式。

**配置示例 (application.yml)：**

```YAML
spring:
  jackson:
    # 设置日期格式 (针对 Date 和 LocalDateTime)
    date-format: yyyy-MM-dd HH:mm:ss
    # 设置时区 (非常重要，否则可能少8小时)
    time-zone: GMT+8
    # 某些版本可能需要显式开启写入时间戳为 false
    serialization:
      write-dates-as-timestamps: false
```

*注意：此方法主要解决 JSON 交互。如果 GET 请求参数解析报错，仍然可能需要配合 `@DateTimeFormat` 或下面的方法三。*



<font color = 'red'>如果继承了WebMvcConfigurationSupport ，或者自定义转换器即实现了WebMvcConfigurer接口，那么yml配置将会失效。</font>

**`WebMvcConfigurationSupport` 是 Spring MVC 的“高级接管模式”。**

当你继承了这个类时，Spring Boot 认为：“**好吧，这个开发者想完全自己控制 MVC 配置，那我就把我自动配置的那套东西（包括读取 `application.yml` 里的 Jackson 配置）全部关掉。**”

**后果就是：**

1. Spring Boot 默认的 `JacksonAutoConfiguration` 失效了。
2. 你的 `application.yml` 里的 `spring.jackson.date-format` 配置被完全忽略了。
3. 系统回退到了最原始的 Jackson 状态（日期默认转为时间戳数组）。



## 方法三：全局代码扩展（最强力，兜底方案）

**适用场景：** 配置文件无法满足需求，或者需要对序列化器做非常复杂的自定义配置（比如你提供的图片中的情况）。

**核心点：** 实现 `WebMvcConfigurer` 接口，重写 `extendMessageConverters`，手动将自定义的 Jackson 转换器加入到 Spring 容器中，并**设为最高优先级**。

```Java
public class JacksonObjectMapper extends ObjectMapper {

    // 定义日期时间的格式常量
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();

        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        // 创建一个模块，用于注册自定义的序列化器和反序列化器
        // ------------------ 反序列化配置 (Input: JSON字符串 -> Java对象) ------------------
        // 当前端传来 "2025-12-01 12:00:00" 时，自动解析为 LocalDateTime 对象
        // ------------------ 序列化配置 (Output: Java对象 -> JSON字符串) ------------------
        // 当后端返回 LocalDateTime 对象时，自动转为 "yyyy-MM-dd HH:mm:ss" 格式的字符串
        SimpleModule module = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        // 将在这个模块中配置的所有规则，注册到 ObjectMapper 中
        this.registerModule(module);
    }
}
```



```java
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 扩展 Spring MVC 框架的消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {

        log.info("扩展消息转换器...");

        // 1. 创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();

        // 2. 需要为消息转换器设置一个对象转换器，对象转换器可以将 Java 对象序列化为 JSON 数据
        converter.setObjectMapper(new JacksonObjectMapper());

        // 3. 将自己的消息转换器加入到容器中
        converters.add(1, converter);
    }
}
```

！<font color='red'>knife4j 4.0.0以上版本不要用最高优先级 0，否则接口文档会异常</font>

> converters.add(1, converter);
>
> 优先级可以选择区间 [1, converters.size() - 1]



## 总结对比

| **方法**                                         | **作用范围**  | **优点**                       | **缺点**                         | **你的选择**               |
| ------------------------------------------------ | ------------- | ------------------------------ | -------------------------------- | -------------------------- |
| **方法一：注解** (@JsonFormat / @DateTimeFormat) | 单个字段      | 灵活，哪里需要加哪里           | 每个字段都要写，容易漏，代码冗余 | **个别特殊字段用它**       |
| **方法二：配置文件** (application.yml)           | 全局 (仅JSON) | 简单，无侵入，不用写 Java 代码 | 对 GET 请求参数支持较弱          | **首选方案**               |
| **方法三：配置类** (WebMvcConfigurer)            | 全局 (JSON)   | 极其强大，可完全掌控序列化逻辑 | 代码量大，逻辑相对复杂           | **当配置文件搞不定时用它** |



# 通用更新方法

## 修改前

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Operation(summary = "启用禁用员工账号")
    @PostMapping("/status/{status}")
    public Result updateStatus(@PathVariable Integer status, Long id) {
        log.info("启用禁用员工账号: {}, {}", status, id);
        employeeService.updateStatus(status, id);
        return Result.success();
    }
```

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     */
    @Override
    public void updateStatus(Integer status, Long id) {
        LambdaUpdateWrapper<Employee> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(Employee::getId, id).set(Employee::getStatus, status);
        this.update(wrapper);
    }
```



## 修改后

```java
    /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Operation(summary = "启用禁用员工账号")
    @PostMapping("/status/{status}")
    public Result updateStatus(@PathVariable Integer status, Long id) {
        log.info("启用禁用员工账号: {}, {}", status, id);
        employeeService.update(Employee.builder().id(id).status(status).build());
        return Result.success();
    }
```

```java
    /**
     * 通用员工更新
     * @param employee
     */
    @Override
    public void update(Employee employee) {
        LambdaUpdateWrapper<Employee> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(Employee::getId, employee.getId())
                .set(employee.getName() != null, Employee::getName, employee.getName())
                .set(employee.getUsername() != null, Employee::getUsername, employee.getUsername())
                .set(employee.getPassword() != null, Employee::getPassword, employee.getPassword())
                .set(employee.getPhone() != null, Employee::getPhone, employee.getPhone())
                .set(employee.getSex() != null, Employee::getSex, employee.getSex())
                .set(employee.getIdNumber() != null, Employee::getIdNumber, employee.getIdNumber())
                .set(employee.getUpdateTime() != null, Employee::getUpdateTime, employee.getUpdateTime())
                .set(employee.getUpdateUser() != null, Employee::getUpdateUser, employee.getUpdateUser())
                .set(employee.getStatus() != null, Employee::getStatus, employee.getStatus());
        this.update(wrapper);
    }
```



# 使用Integer区分“未传参”和“传了值为0”

```java
    /**
     * 分类分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    @Override
    public PageResult<CategoryPageQueryVO> page(CategoryPageQueryDTO categoryPageQueryDTO) {
        IPage<Category> iPage = new Page<>(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize());
        LambdaQueryWrapper<Category> wrapper = new LambdaQueryWrapper<>();
        wrapper.like(StringUtils.hasText(categoryPageQueryDTO.getName()), Category::getName, categoryPageQueryDTO.getName())
                .eq(categoryPageQueryDTO.getType() != null, Category::getType, categoryPageQueryDTO.getType())
                .orderByDesc(Category::getSort);
        this.page(iPage, wrapper);
        List<CategoryPageQueryVO> records = iPage.getRecords().stream().map(category -> {
            CategoryPageQueryVO vo = new CategoryPageQueryVO();
            BeanUtils.copyProperties(category, vo);
            return vo;
        }).toList();
        return new PageResult<>(iPage.getTotal(), records);
    }
```

`categoryPageQueryDTO.getType() != null` 将`CategoryPageQueryDTO` 的 `type` 属性的类型从 `int` 改成 `Integer` 这样就可以判空。



# 公共字段自动填充

## 手动实现

![image-20251208224654852](./assets/image-20251208224654852.png)



![image-20251208225132540](./assets/image-20251208225132540.png)



<img src="./assets/image-20251208230332154.png" alt="image-20251208230332154" style="zoom: 67%;" />

<img src="./assets/image-20251208230410449.png" alt="image-20251208230410449" style="zoom: 67%;" />



<img src="./assets/image-20251208230824047.png" alt="image-20251208230824047" style="zoom:67%;" />

<img src="./assets/image-20251208230912674.png" alt="image-20251208230912674" style="zoom:67%;" />

![image-20251208231303579](./assets/image-20251208231303579.png)





反射与参数处理

在自定义切面（Aspect）中，我们需要同时操作“规则”（注解）和“数据”（实体对象）。这涉及到 `JoinPoint` 的两个核心用法。

1. 核心概念对比

| **核心组件** | **MethodSignature (方法签名)**                   | **joinPoint.getArgs() (参数数组)**         |
| ------------ | ------------------------------------------------ | ------------------------------------------ |
| **性质**     | **静态元数据 (Metadata)**                        | **动态运行时数据 (Runtime Data)**          |
| **比喻**     | **菜谱 / 模具**                                  | **刚买回来的菜 / 实物**                    |
| **作用**     | 告诉你代码是怎么**写**的。                       | 给你看程序正在**跑**的数据。               |
| **核心用途** | 获取方法名、**读取方法上的注解**、查看参数类型。 | 获取**前端传来的实体对象**、进行反射赋值。 |
| **获取方式** | `(MethodSignature) joinPoint.getSignature()`     | `joinPoint.getArgs()`                      |



2. 详细解析

A. 为什么要强转 `MethodSignature`？

- **问题**：`joinPoint.getSignature()` 返回的是最顶层的 `Signature` 接口。它只知道“这是一个连接点”，但不知道这是个“方法”。
- **解决**：必须向下转型（强转）为 `MethodSignature`。
- **目的**：只有转了之后，才能调用 `.getMethod()` 拿到 `java.lang.reflect.Method` 对象，进而通过 `.getAnnotation(AutoFill.class)` 读取我们在方法上写的注解（判断是 `INSERT` 还是 `UPDATE`）。

B. 为什么要用 `getArgs()`？

- **问题**：`Method` 对象里只有“参数类型”（比如 `Employee.class`），没有“参数值”。
- **解决**：通过 `joinPoint.getArgs()` 获取一个 `Object[]` 数组。
- **目的**：数组中的 `args[0]` 就是前端传进来的、活生生的实体对象（内存地址）。我们需要拿到它，才能通过反射（Reflection）把 `createTime` 等值塞进去。



3. 标准代码模板

```Java
@Before("@annotation(com.sky.annotation.AutoFill)") // 拦截带有 @AutoFill 注解的方法
public void autoFill(JoinPoint joinPoint) {

    // ================= Phase 1: 获取“规则” (MethodSignature) =================
    // 1. 获取签名并强转 (这是通往 Method 对象的唯一桥梁)
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    
    // 2. 获取 Method 对象 (反射的核心)
    Method method = signature.getMethod();
    
    // 3. 获取方法上的注解 (读取你是 INSERT 还是 UPDATE)
    AutoFill autoFill = method.getAnnotation(AutoFill.class);
    OperationType operationType = autoFill.value();


    // ================= Phase 2: 获取“数据” (Args) =================
    // 1. 获取参数数组
    Object[] args = joinPoint.getArgs();
    
    // 2. 防御性编程 (防止无参数方法报错)
    if (args == null || args.length == 0) {
        return;
    }
    
    // 3. 锁定目标对象 (通常约定第一个参数是实体对象)
    Object entity = args[0];


    // ================= Phase 3: 执行“操作” (Reflection) =================
    // 准备数据
    LocalDateTime now = LocalDateTime.now();
    Long currentId = BaseContext.getCurrentId();

    // 通过反射赋值 (根据 operationType 决定填充哪些字段)
    if (operationType == OperationType.INSERT) {
        // 伪代码：通过反射调用 entity.setCreateTime(now);
        // ...
    }
}
```



![image-20251208232231161](./assets/image-20251208232231161.png)



## Mybatis-Plus直接使用

### 使用步骤

#### 1. 定义实体类

在实体类中，你需要使用 `@TableField` 注解来标记哪些字段需要自动填充，并指定填充的策略。

```java
public class User {
    @TableField(fill = FieldFill.INSERT)
    private String createTime;

    @TableField(fill = FieldFill.UPDATE)
    private String updateTime;

    // 其他字段...
}
```

#### 2. 实现 MetaObjectHandler

创建一个类来实现 `MetaObjectHandler` 接口，并重写 `insertFill` 和 `updateFill` 方法。

```java
@Slf4j
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("开始插入填充...");
        this.strictInsertFill(metaObject, "createUserId", Long.class, 123456L)
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("开始更新填充...");
        this.strictInsertFill(metaObject, "updateUserId", Long.class, 123456L)
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
    }
}
```

#### 3. 配置自动填充处理器

确保你的 `MyMetaObjectHandler` 类被 Spring 管理，可以通过 `@Component` 或 `@Bean` 注解来实现。

### 注意事项

- 自动填充是直接给实体类的属性设置值。
- 如果属性没有值，入库时会是 `null`。
- `MetaObjectHandler` 提供的默认方法策略是：如果属性有值则不覆盖，如果填充值为 `null` 则不填充。
- 字段必须声明 `@TableField` 注解，并设置 `fill` 属性来选择填充策略。
- 填充处理器需要在 Spring Boot 中声明为 `@Component` 或 `@Bean`。
- 使用 `strictInsertFill` 或 `strictUpdateFill` 方法可以根据注解 `FieldFill.xxx`、字段名和字段类型来区分填充逻辑。
- 如果不需区分，可以使用 `fillStrategy` 方法。
- 在 `update(T entity, Wrapper<T> updateWrapper)` 时，`entity` 不能为空，否则自动填充失效。
- <font color='red'>在 `update(Wrapper<T> updateWrapper)` 时不会自动填充，需要手动赋值字段条件。</font>



`update(entity, wrapper)` 是 MyBatis-Plus 中一个非常灵活的方法，它的核心逻辑是：**“对象负责数据，Wrapper 负责条件”**。

它完美解决了你遇到的“想用复杂条件更新，又想让自动填充生效”的问题。

- **参数 1 (`entity`)**：决定 `UPDATE` 语句中的 **SET** 部分（以及触发自动填充）。
- **参数 2 (`wrapper`)**：决定 `UPDATE` 语句中的 **WHERE** 部分。



手动实现中，反射需要依靠方法名

```java
package com.hongs.skycommon.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant {
    public static final String SET_CREATE_TIME = "setCreateTime";
    public static final String SET_UPDATE_TIME = "setUpdateTime";
    public static final String SET_CREATE_USER = "setCreateUser";
    public static final String SET_UPDATE_USER = "setUpdateUser";
}
```



Mybatis-Plus，的使用中只需要属性即可

```java
package com.hongs.skycommon.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant {
    public static final String CREATE_TIME = "createTime";
    public static final String UPDATE_TIME = "updateTime";
    public static final String CREATE_USER = "createUser";
    public static final String UPDATE_USER = "updateUser";
}
```



### MP仅用属性名的原因

MP底层是反射调用了 `set` 方法（或者直接操作字段），**但是**，MyBatis-Plus（以及 MyBatis 核心）的设计逻辑遵循了 **JavaBean 规范** 和 **元数据管理** 的原则。

这里之所以**必须是属性名**（`createTime`）而不是方法名（`setCreateTime`），主要有以下三个核心原因：



#### 1. MyBatis 的 `MetaObject` 机制（中间人模式）

MyBatis-Plus 的自动填充底层依赖于 MyBatis 原生的工具类 `MetaObject`。

`MetaObject` 是一个强大的对象包装器，它的设计理念是：**“给我属性名，我来负责找存取方法”**。它屏蔽了具体的实现细节。

当你调用 `metaObject.setValue("name", "张三")` 时，内部流程是这样的：

1. **查找属性**：MyBatis 会去 `Reflector`（反射器）中查找名为 `name` 的属性信息。
2. **解析 Setter**：
	- 标准 JavaBean：它会自动拼凑出 `setName`。
	- Lombok `@Accessors(fluent=true)`：Setter 可能叫 `name()`。
	- Boolean 类型：Setter 可能叫 `isName()` 或 `setName()`。
3. **调用**：反射调用找到的方法。

**结论**：如果你传给它 `"setName"`，`MetaObject` 会以为你有一个属性叫 `setName`（对应的 Setter 应该是 `setSetName`），这显然是找不到的。



#### 2. MP 的 `strictFill` 需要获取字段元数据

注意你调用的方法名是 `strictInsertFill`（严格填充）。这个“严格”体现在：它不仅仅是赋值，它还要**检查字段是否存在**以及**类型是否匹配**。

MP 的源码逻辑大致如下（伪代码）：

```Java
public void strictFill(MetaObject metaObject, String fieldName, Class<?> fieldType, Object fieldVal) {
    // 1. MP 拿着你传入的 "createTime" 去类定义里找 Field 对象
    // 如果你传 "setCreateTime"，这里直接报错：没有这个字段！
    if (metaObject.hasSetter(fieldName) && metaObject.hasGetter(fieldName)) {
        
        // 2. 检查类型是否匹配 (比如你要填 LocalDateTime，但字段是 String)
        Class<?> setterType = metaObject.getSetterType(fieldName);
        if (setterType.isAssignableFrom(fieldType)) {
            
            // 3. 执行填充
            metaObject.setValue(fieldName, fieldVal);
        }
    }
}
```

如果 MP 要求你传入方法名 `"setCreateTime"`，那么它就无法反向推导出字段名是 `createTime`（因为可能存在非标准的命名），也就无法获取字段上的注解（如 `@TableField`）或者类型信息。



#### 3. 解耦与稳定性

在 Java 开发中，**属性名（Field）** 是数据的核心标识，而 **Setter 方法名** 是一种行为实现。

- **场景 A**：你使用了 Lombok 的 `@Accessors(chain = true)` 或 `@Builder`，或者你是 Kotlin 用户，Setter 方法的签名或名称可能会变。
- **场景 B**：你可能根本没有 Setter 方法，而是配置了 MyBatis 直接通过反射操作 Field（不走 set 方法）。

如果 MP 强制绑定“方法名”，一旦上述场景发生，自动填充就废了。绑定“属性名”则是最稳定、最符合面向对象设计的做法。



#### 图解流程

**手动实现：**

> 常量 "setCreateTime"  -->  反射调用 setCreateTime()

**实际的 MP/MyBatis 逻辑：**

> 常量 "createTime" (属性名)
>
> ⬇️
>
> 1. `Reflector` 查找名为 `createTime` 的属性定义
>
> 2. 获取该属性对应的 Setter 方法（例如 `setCreateTime`）
>
> 3. 获取该属性的类型（用于类型检查）
>
> 	⬇️
>
> 	反射调用 setCreateTime()



# 工具类保持启动时单例

```java
/**
 * AliOSSUtil配置类
 */
@Configuration
@Slf4j
public class AliOSSConfig {
    @Bean
    @ConditionalOnMissingBean
    public AliOSSUtil aliOSSUtil(AliOSSProperties aliOSSProperties) {
        log.info("开始创建AliOSSUtil对象...");
        return new AliOSSUtil(aliOSSProperties.getEndpoint(),
                aliOSSProperties.getAccessKeyId(),
                aliOSSProperties.getAccessKeySecret(),
                aliOSSProperties.getBucketName(),
                aliOSSProperties.getRegion());
    }
}
```

| **对比维度**     | **仅使用 @Bean**                                             | **使用 @Bean + @ConditionalOnMissingBean**                   |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **创建逻辑**     | **强制创建**。无论容器中是否已存在该类型的 Bean，都会尝试注册当前的 Bean 定义。 | **按需创建**。先检查容器中是否已存在该类型的 Bean。若不存在才创建；若已存在则忽略，不执行创建逻辑。 |
| **冲突处理**     | **报错或覆盖**。如果容器中已有同名 Bean，默认情况下 Spring Boot (2.1+) 会抛出 `BeanDefinitionOverrideException` 异常导致启动失败。 | **礼貌避让**。如果容器中已有同名或同类型的 Bean，当前配置自动失效，系统继续运行，使用已存在的那个 Bean。 |
| **优先级定位**   | **一等公民**。认为是系统中不可或缺、不可替代的定义。         | **兜底策略 (Fallback)**。认为是“备胎”或“默认值”，允许被更高优先级的自定义配置取代。 |
| **典型应用场景** | **业务代码 (Application Code)**。如 Controller、Service、或项目特有的配置。你不希望这些代码被意外替换。 | **自动配置 (Auto-Configuration)**。如编写 SDK、Starter 或通用工具库。你希望给用户提供默认功能，但允许用户自定义去覆盖它。 |
| **灵活性**       | **低**。外部很难替换该 Bean，除非修改源码或开启允许 Bean 覆盖的全局配置。 | **高**。外部只需定义一个同类型的 Bean，即可轻松替换掉这个默认实现，无需修改你的源码。 |



# 文件上传的文件名设置

## 上传配置

```java
@Operation(summary = "文件上传")
@PostMapping("/update")
public Result<String> update(MultipartFile file) {
    log.info("文件上传");
    try {
        // 生成文件名: UUID + 文件后缀
        String fileName = UUID.randomUUID().toString() + file.getName().substring(file.getName().lastIndexOf("."));

        // 按年月文件上传路径
        String objectName = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM")) + "/" + fileName;

        String url = aliOSSUtil.upload(objectName, file.getBytes());
        return Result.success(url);
    } catch (IOException e) {
        throw new BaseException(MessageConstant.UPLOAD_FAILED);
    }
}
```

```yml
spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
```



## 分目录的原因

**技术上不强制（OSS 是扁平的），但在工程实践中，强烈建议分目录。**

### 1. 核心原理：对象存储其实是“假的”文件系统

Windows 或 Linux 的文件系统，文件夹是真的存在的。 但在对象存储（OSS、S3）中，**本质上它是 Key-Value 的结构**，它是扁平的。

- **你以为的结构：** `folder` (文件夹) -> `subfolder` (子文件夹) -> `file.jpg`
- **OSS 实际存储的结构：** 它只存了一个 Key（文件名），这个 Key 的字符串就是：`folder/subfolder/file.jpg`。 **“/” 对 OSS 来说，只是文件名字符串的一部分而已。**

### 2. 既然是扁平的，为什么还要我手动加 "/" 分层？

虽然底层是扁平的，但 **分层（分目录）** 有以下 3 个巨大的实际价值：

#### ① 避免“控制台爆炸” (最直接的原因)

阿里云、AWS 的网页版管理控制台（Console），都会把 `/` 识别为模拟文件夹。

- **如果不分目录：** 假设你存了 10 万张图在根目录。当你登录阿里云 OSS 后台想找某张图时，浏览器会尝试加载这 10 万条记录。**结果通常是：网页卡死、崩溃，或者加载极慢。**
- **如果分目录：** 打开根目录，你只看到几个年份文件夹（如 `2023/`, `2024/`），系统非常流畅。

#### ② 数据管理与生命周期 (最值钱的原因)

OSS 都有**生命周期管理 (Lifecycle)** 功能。

- **场景：** 老板说，“原本去年的临时图片（temp）太占钱了，我们要自动删除，但保留今年的”。
- **没目录：** 你完了。所有图片都在一起，怎么区分哪张是去年的？只能写脚本一个个遍历（耗时耗钱）。
- **有目录：** 你可以直接在阿里云后台配一条规则：**“对前缀为 `2023/temp/` 的对象，设置 30 天后自动删除。”** —— **一键搞定。**

#### ③ 性能优化 (Listing 性能)

如果你需要通过 API 列出某个文件，虽然 OSS 很快，但如果你在根目录下 List Object，而根目录下有 100 万个文件，API 只能分页返回（比如一次 1000 个）。你要找到第 90 万个文件，需要请求 900 次 API。 如果有目录结构，你可以直接 List `2024/10/12/` 下的文件，效率高得多。
